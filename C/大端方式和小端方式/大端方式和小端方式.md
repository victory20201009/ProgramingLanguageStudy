<center><font color="#FFA500" size="6">大端方式和小端方式</font></center>

[toc]

# 1 大端模式和小端模式的起源

> ​    关于大端小端名词的由来，有一个有趣的故事，来自于Jonathan Swift的《格利佛游记》：Lilliput和Blefuscu这两个强国在过去的36个月中一直在苦战。战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可以那时的皇帝的祖父由于小时侯吃鸡蛋，按这种方法把手指弄破了，因此他的父亲，就下令，命令所有的子民吃鸡蛋的时候，必须先打破鸡蛋较小的一端，违令者重罚。然后老百姓对此法令极为反感，期间发生了多次叛乱，其中一个皇帝因此送命，另一个丢了王位，产生叛乱的原因就是另一个国家Blefuscu的国王大臣煽动起来的，叛乱平息后，就逃到这个帝国避难。据估计，先后几次有11000余人情愿死也不肯去打破鸡蛋较小的端吃鸡蛋。这个其实讽刺当时英国和法国之间持续的冲突。Danny Cohen一位网络协议的开创者，第一次使用这两个术语指代字节顺序，后来就被大家广泛接受。

# 2 什么是大端和小端

一般的，计算机的存储器地址是按照字节编制的，并且是连续递增的，如果一个数据包含了多个字节，例如一个int类型的值，有四个字节，不妨是：`0x12345678`这四个字节是连续存放在存储器中的，其中`0x12`，`0x34`，`0x56`，`0x78`分别占用一个字节，那么这四个字节如何放在存储器中呢（乱序摆放肯定是没有意义的）？内存单元地址从高到低分别是`0x12`，`0x34`，`0x56`，`0x78`，还是`0x78`，`0x56`，`0x34`，`0x12`呢？这就是大端和小端的问题。

总结起来就是：大端和小端是描述多字节数据中的多个字节在计算机内部（例如存储器，寄存器等）是如何摆放的概念。

大端方式：起源故事中描述到，人们一般习惯打破鸡蛋大的一端，在整数`0x12345678`中，按照人们的一般习惯，从左往右，地址递增，那么`0x12`就放在较低的地址，`0x78`放在较高的地址。

小端方式：与大端方式正好相反

优劣对比：

- 小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。
- 大端模式 ：符号位的判定固定为第一个字节，容易判断正负。

# 3 判断当前计算机是大端和小端

1. 方式1

   ```C++
   bool IsBigEndian()  
   {  
       int a = 0x1234;  
       char b =  *(char *)&a;  //把a的地址，转换成单字节char的指针， 在通过*运算符获取到内容，就是变量a第一个字节的内容，对于大端方式，第一个字节的内容存放的是高位，小端方式相反
       if( b == 0x12)  
       {  
           return true;  
       }  
       return false;  
   }
   ```

2. 方式2

   ```C++
   //联合体的所有成员都是从同一个地方开始存放的，当给 num.a 赋值为 0x1234时，其b成员被赋值为a的首个字节的内容
   bool IsBigEndian()  
   {  
       union NUM  
       {  
           int a;  
           char b;  
       }num;  
       num.a = 0x1234;
       if( num.b == 0x12 )  
       {  
           return true;  
       }  
       return false;  
   }
   ```

# 4 常见的字节序

1. 常见CPU的字节序

   Endian : PowerPC、IBM、Sun
   Little Endian : x86、DEC
   ARM既可以工作在大端模式，也可以工作在小端模式。

2. 常见文件的字节序

   Adobe PS – Big Endian
   BMP – Little Endian
   DXF(AutoCAD) – Variable
   GIF – Little Endian
   JPEG – Big Endian
   MacPaint – Big Endian
   RTF – Little Endian

3. 一般的网络协议的实现都是用大端方式

# 5 大小端的转换

方法大概就是，把不同的字节挪动位置，具体实现上是通过移位+或操作。

```C++
//16位数据的大小端转换
#define BigtoLittle16(A)   (( ((uint16)(A) & 0xff00) >> 8)    | \  
                                       (( (uint16)(A) & 0x00ff) << 8))
//32位数据的大小端转换
#define BigtoLittle32(A)   ((( (uint32)(A) & 0xff000000) >> 24) | \  
                                       (( (uint32)(A) & 0x00ff0000) >> 8)   | \  
                                       (( (uint32)(A) & 0x0000ff00) << 8)   | \  
                                       (( (uint32)(A) & 0x000000ff) << 24))  
```

如进行网络数据传递时，必须要考虑端模式的转换。在Socket接口编程中，相关函数库提供以下几个函数用于大小端字节序的转换。

```C++
#define ntohs(n)     //16位数据类型网络字节顺序到主机字节顺序的转换  
#define htons(n)     //16位数据类型主机字节顺序到网络字节顺序的转换  
#define ntohl(n)      //32位数据类型网络字节顺序到主机字节顺序的转换  
#define htonl(n)      //32位数据类型主机字节顺序到网络字节顺序的转换  
```

 大端模式处理器的字节序到网络字节序不需要转换，此时ntohs(n)=n，ntohl = n；而小端模式处理器的字节序到网络字节必须要进行转换，此时ntohs(n) = \_\_swab16(n)，ntohl = \_\_swab32(n)。\_\_swab16与__swab32函数定义如下所示。

```C++
#define ___swab16(x)  
{  
            __u16 __x = (x);  
            ((__u16)(  
                        (((__u16)(__x) & (__u16)0x00ffU) << 8) |  
                        (((__u16)(__x) & (__u16)0xff00U) >> 8) ));  
}  
  
  
#define ___swab32(x)  
{  
            __u32 __x = (x);  
            ((__u32)(  
                        (((__u32)(__x) & (__u32)0x000000ffUL) << 24) |  
                        (((__u32)(__x) & (__u32)0x0000ff00UL) << 8) |  
                        (((__u32)(__x) & (__u32)0x00ff0000UL) >> 8) |  
                        (((__u32)(__x) & (__u32)0xff000000UL) >> 24) ));  
}  
```

# 6 从系统的角度理解端模式

> 先补充两个关键词，MSB和LSB：
> 　　  MSB:MoST Significant Bit ------- 最高有效位
>     LSB:Least Significant Bit ------- 最低有效位
>
>  
>
> ​    处理器在硬件上由于端模式问题在设计中有所不同。从系统的角度上看，端模式问题对软件和硬件的设计带来了不同的影响，当一个处理器系统中大小端模式同时存在时，必须要对这些不同端模式的访问进行特殊的处理。
> ​    PowerPC处理器主导网络市场，可以说绝大多数的通信设备都使用PowerPC处理器进行协议处理和其他控制信息的处理，这也可能也是在网络上的绝大多数协议都采用大端编址方式的原因。因此在有关网络协议的软件设计中，使用小端方式的处理器需要在软件中处理端模式的转变。而Pentium主导个人机市场，因此多数用于个人机的外设都采用小端模式，包括一些在网络设备中使用的PCI总线，Flash等设备，这也要求在硬件设计中注意端模式的转换。
> ​    本文提到的小端外设是指这种外设中的寄存器以小端方式进行存储，如PCI设备的配置空间，NOR FLASH中的寄存器等等。对于有些设备，如DDR颗粒，没有以小端方式存储的寄存器，因此从逻辑上讲并不需要对端模式进行转换。在设计中，只需要将双方数据总线进行一一对应的互连，而不需要进行数据总线的转换。
> ​    如果从实际应用的角度说，采用小端模式的处理器需要在软件中处理端模式的转换，因为采用小端模式的处理器在与小端外设互连时，不需要任何转换。而采用大端模式的处理器需要在硬件设计时处理端模式的转换。大端模式处理器需要在寄存器，指令集，数据总线及数据总线与小端外设的连接等等多个方面进行处理，以解决与小端外设连接时的端模式转换问题。在寄存器和数据总线的位序定义上，基于大小端模式的处理器有所不同。
> ​    一个采用大端模式的32位处理器，如基于E500内核的MPC8541，将其寄存器的最高位msb（most significant bit）定义为0，最低位lsb（lease significant bit）定义为31；而小端模式的32位处理器，将其寄存器的最高位定义为31，低位地址定义为0。与此向对应，采用大端模式的32位处理器数据总线的最高位为0，最高位为31；采用小端模式的32位处理器的数据总线的最高位为31，最低位为0。     
> ​    大小端模式处理器外部总线的位序也遵循着同样的规律，根据所采用的数据总线是32位，16位和8位，大小端处理器外部总线的位序有所不同。大端模式下32位数据总线的msb是第0位，MSB是数据总线的第0~7的字段；而lsb是第31位，LSB是第24~31字段。小端模式下32位总线的msb是第31位，MSB是数据总线的第31~24位，lsb是第0位，LSB是7~0字段。大端模式下16位数据总线的msb是第0位，MSB是数据总线的第0~7的字段；而lsb是第15位，LSB是第8~15字段。小端模式下16位总线的msb是第15位，MSB是数据总线的第15~7位，lsb是第0位，LSB是7~0字段。大端模式下8位数据总线的msb是第0位，MSB是数据总线的第0~7的字段；而lsb是第7位，LSB是第0~7字段。小端模式下8位总线的msb是第7位，MSB是数据总线的第7~0位，lsb是第0位，LSB是7~0字段。
> ​     由上分析，我们可以得知对于8位，16位和32位宽度的数据总线，采用大端模式时数据总线的msb和MSB的位置都不会发生变化，而采用小端模式时数据总线的lsb和LSB位置也不会发生变化。
> ​     为此，大端模式的处理器对8位，16位和32位的内存访问（包括外设的访问）一般都包含第0~7字段，即MSB。小端模式的处理器对8位，16位和32位的内存访问都包含第7~0位，小端方式的第7~0字段，即LSB。由于大小端处理器的数据总线其8位，16位和32位宽度的数据总线的定义不同，因此需要分别进行讨论在系统级别上如何处理端模式转换。在一个大端处理器系统中，需要处理大端处理器对小端外设的访问。

# 7 实际中的例子

虽然很多时候，字节序的工作已由编译器完成了，但是在一些小的细节上，仍然需要去仔细揣摩考虑，尤其是在以太网通讯、MODBUS通讯、软件移植性方面。这里，举一个MODBUS通讯的例子。在MODBUS中，数据需要组织成数据报文，该报文中的数据都是大端模式，即低地址存高位，高地址存低位。假设有一16位缓冲区m_RegMW[256]，因为是在x86平台上，所以内存中的数据为小端模式：m_RegMW[0].low、m_RegMW[0].high、m_RegMW[1].low、m_RegMW[1].high……
为了方便讨论，假设m_RegMW[0] = 0x3456; 在内存中为0x56、0x34。
    现要将该数据发出，如果不进行数据转换直接发送，此时发送的数据为0x56,0x34。而Modbus是大端的，会将该数据解释为0x5634而非原数据0x3456，此时就会发生灾难性的错误。所以，在此之前，需要将小端数据转换成大端的，即进行高字节和低字节的交换，此时可以调用步骤五中的函数BigtoLittle16(m_RegMW[0])，之后再进行发送才可以得到正确的数据。